<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8" />
	<title>One Up Puzzle Visualizer</title>

	<style>
		body {
			font-family: sans-serif;
			margin: 20px;
		}

		table {
			border-collapse: collapse;
		}

		td {
			width: 80px;
			height: 80px;
			text-align: center;
			vertical-align: middle;
			border: 1px solid #ccc;
			font-size: 36px;
		}

		/* Thicker segment boundary styles */
		.segment-left {
			border-left: 3px solid #000 !important;
		}

		.segment-top {
			border-top: 3px solid #000 !important;
		}

		.segment-right {
			border-right: 3px solid #000 !important;
		}

		.segment-bottom {
			border-bottom: 3px solid #000 !important;
		}

		#controls {
			margin-bottom: 10px;
		}

		#iterationCount {
			font-weight: bold;
		}
	</style>
</head>

<body>

	<div id="controls">
		<button id="iterateBtn">Generate</button>
		<span>Iterations to generate: <span id="iterationCount">0</span></span>
	</div>

	<div id="gridContainer"></div>

	<script>
		/************************************************************
		 *  Utility: segmentLine(line)
		 *  Greedily splits a 1D array (line) into segments whenever
		 *  a repeated digit is encountered, starting a new segment
		 *  at that digit. Returns an array of segments.
		 ************************************************************/
		function segmentLine(line)
		{
			const segments = [];
			let currentSegment = [];
			let seen = new Set();

			for (const digit of line)
			{
				if (seen.has(digit))
				{
					// Close off the current segment
					segments.push(currentSegment);
					// Start a new segment with the repeated digit
					currentSegment = [digit];
					seen.clear();
					seen.add(digit);
				} else
				{
					currentSegment.push(digit);
					seen.add(digit);
				}
			}
			if (currentSegment.length > 0)
			{
				segments.push(currentSegment);
			}
			return segments;
		}

		/************************************************************
		 *  Utility: isSegmentValid(segment)
		 *  A segment of length M is valid if it contains exactly
		 *  the digits [1..M].
		 ************************************************************/
		function isSegmentValid(segment)
		{
			const M = segment.length;
			// If any digit is outside [1..M], it's invalid
			if (segment.some(d => d < 1 || d > M))
			{
				return false;
			}
			// Must have exactly M distinct digits
			const uniqueDigits = new Set(segment);
			return (uniqueDigits.size === M);
		}

		/************************************************************
		 *  Utility: checkLineValidity(line)
		 *  Splits into segments, checks each segment for validity.
		 ************************************************************/
		function checkLineValidity(line)
		{
			const n = line.length;

			// dp[i] = true if line[0..i-1] can be segmented into valid segments
			const dp = new Array(n + 1).fill(false);
			dp[0] = true; // empty subarray is trivially valid

			for (let i = 1; i <= n; i++)
			{
				// We want to see if there's any j < i such that dp[j] = true
				// and line[j..i-1] is a valid segment.
				for (let j = 0; j < i; j++)
				{
					if (dp[j])
					{
						const segment = line.slice(j, i); // subarray from j to i-1
						if (isSegmentValid(segment))
						{
							dp[i] = true;
							break; // No need to look further once dp[i] is true
						}
					}
				}
			}

			return dp[n]; // true if the entire line can be segmented
		}

		/************************************************************
		 *  Check a single row for validity
		 ************************************************************/
		function checkRow(grid, r)
		{
			return checkLineValidity(grid[r]);
		}

		/************************************************************
		 *  Check a single column for validity
		 ************************************************************/
		function checkColumn(grid, c)
		{
			const col = grid.map(row => row[c]);
			return checkLineValidity(col);
		}

		/************************************************************
		 *  We'll define N and our grid globally for simplicity
		 ************************************************************/
		const N = 7;         // Grid size
		let iterationCount = 0;
		let grid = Array.from({ length: N }, () => Array(N).fill(1));

		/**
		 * Returns an array of boundary indices for a valid One Up segmentation 
		 * of "line". Uses a DP approach:
		 *   - dp[i] stores the index j where the segment line[j..i-1] is valid
		 *     and dp[j] was also valid. (-1 if no such j exists.)
		 *   - If dp[line.length] != -1, we can reconstruct boundaries by
		 *     following these links backwards.
		 *
		 * Example:
		 *   line = [1, 3, 1, 2]
		 *   A valid segmentation is [1] | [3,1,2].
		 *   Boundaries might be [0, 1, 4] (segment from 0..0, then 1..3).
		 */
		function computeLineBoundaries(line)
		{
			const n = line.length;

			// We'll store dp[i] = j meaning line[j..i-1] is a valid segment,
			// and dp[j] != -1, so line[0..j-1] can be segmented too.
			// Initialize to -1 (invalid). dp[0] = 0 means "start from 0 is valid".
			const dp = new Array(n + 1).fill(-1);
			dp[0] = 0;

			for (let i = 1; i <= n; i++)
			{
				for (let j = 0; j < i; j++)
				{
					if (dp[j] !== -1 && isSegmentValid(line.slice(j, i)))
					{
						dp[i] = j;
						break;
					}
				}
			}

			// If dp[n] == -1, there's no valid segmentation
			if (dp[n] === -1)
			{
				return [];
			}

			// Reconstruct the boundary indices by walking backwards
			const boundaries = [];
			let cur = n;
			while (cur > 0)
			{
				const start = dp[cur]; // j that led to i=cur
				boundaries.push(start);
				cur = start;
			}
			boundaries.reverse();  // Now [0, boundary1, boundary2, ..., n]
			return boundaries;     // Typically youâ€™ll use these to mark thick borders
		}

		/**
	 * Example computeBoundaries using DP segmentation:
	 * 
	 * Returns:
	 *   {
	 *     rowBoundaries: 2D array [r][c], 
	 *     colBoundaries: 2D array [r][c]
	 *   }
	 * where rowBoundaries[r][c] = true means "there is a thick vertical boundary
	 * immediately to the left of cell (r,c)", and 
	 * colBoundaries[r][c] = true means "there is a thick horizontal boundary
	 * immediately above cell (r,c)".
	 */
		function computeBoundaries(grid)
		{
			const rowBoundaries = Array.from({ length: N }, () => Array(N).fill(false));
			const colBoundaries = Array.from({ length: N }, () => Array(N).fill(false));

			// ----- Handle Rows -----
			for (let r = 0; r < N; r++)
			{
				// Get the boundaries for this row
				const boundaries = computeLineBoundaries(grid[r]);
				// boundaries is something like [0, 2, 5, 7, N] for example

				// For convenience, always mark the leftmost boundary
				// if boundaries[0] == 0. That means a thick border at col=0
				// for the row r.
				if (boundaries.length > 0)
				{
					// The first boundary should be 0, but let's just do it anyway.
					rowBoundaries[r][0] = true;

					// For each boundary index b (except the first),
					// mark rowBoundaries[r][b] = true to indicate
					// a vertical boundary to the left of column b.
					// The final boundary is N, which is "just past" the row,
					// so we skip it because it's outside the grid.
					for (let i = 1; i < boundaries.length; i++)
					{
						const b = boundaries[i];
						if (b >= 1 && b < N)
						{
							rowBoundaries[r][b] = true;
						}
					}
				} else
				{
					// If invalid (no boundaries), you might choose
					// to mark the row as fully "no boundaries" or something else.
					// Here we'll just do rowBoundaries[r][0] = true so it
					// at least has a left border.
					rowBoundaries[r][0] = true;
				}
			}

			// ----- Handle Columns -----
			for (let c = 0; c < N; c++)
			{
				// Build the column array
				const columnArray = grid.map(row => row[c]);
				const boundaries = computeLineBoundaries(columnArray);

				if (boundaries.length > 0)
				{
					// Mark the top boundary at row=0
					colBoundaries[0][c] = true;
					for (let i = 1; i < boundaries.length; i++)
					{
						const b = boundaries[i];
						if (b >= 1 && b < N)
						{
							colBoundaries[b][c] = true;
						}
					}
				} else
				{
					// At least mark top boundary
					colBoundaries[0][c] = true;
				}
			}

			return { rowBoundaries, colBoundaries };
		}


		/************************************************************
		 *  Render the grid as an HTML table with thick borders
		 *  between segments.
		 ************************************************************/
		function renderGrid()
		{
			const container = document.getElementById('gridContainer');
			container.innerHTML = ''; // clear old table

			const { rowBoundaries, colBoundaries } = computeBoundaries(grid);

			const table = document.createElement('table');

			for (let r = 0; r < N; r++)
			{
				const tr = document.createElement('tr');
				for (let c = 0; c < N; c++)
				{
					const td = document.createElement('td');
					td.textContent = grid[r][c];

					// If rowBoundaries[r][c] is true, we apply a thick left border
					if (rowBoundaries[r][c])
					{
						td.classList.add('segment-left');
					}
					// If colBoundaries[r][c] is true, we apply a thick top border
					if (colBoundaries[r][c])
					{
						td.classList.add('segment-top');
					}

					// The final row and column always have thick borders
					if (r === N - 1)
					{
						td.classList.add('segment-bottom');
					}
					if (c === N - 1)
					{
						td.classList.add('segment-right');
					}
					tr.appendChild(td);
				}
				table.appendChild(tr);
			}
			container.appendChild(table);
		}

		function getLargestViableValue(grid, r, c, largestValue)
		{
			const oldValue = grid[r][c];
			for (let newValue = largestValue; newValue > oldValue; newValue--)
			{
				// Temporarily assign
				grid[r][c] = newValue;

				// Check row & column
				let isValid = checkRow(grid, r) && checkColumn(grid, c);

				// Revert
				grid[r][c] = oldValue;

				if (isValid)
				{
					return newValue;
				}
			}
			return 0;
		}

		function getLargestValue(grid)
		{
			let largestValue = 0;
			for (let r = 0; r < N; r++)
			{
				for (let c = 0; c < N; c++)
				{
					largestValue = Math.max(largestValue, grid[r][c]);
				}
			}
			return largestValue;
		}

		function hasIslands(grid)
		{
			const { rowBoundaries, colBoundaries } = computeBoundaries(grid);

			if (N === 0) return false; // trivially no islands in empty grid

			const visited = new Set();
			const queue = [[0, 0]];  // Start BFS from top-left
			visited.add("0,0");

			while (queue.length > 0)
			{
				const [r, c] = queue.shift();

				// -- Move Left --
				if (c > 0 && !rowBoundaries[r][c])
				{
					const leftKey = `${r},${c - 1}`;
					if (!visited.has(leftKey))
					{
						visited.add(leftKey);
						queue.push([r, c - 1]);
					}
				}

				// -- Move Right --
				if (c < N - 1 && !rowBoundaries[r][c + 1])
				{
					const rightKey = `${r},${c + 1}`;
					if (!visited.has(rightKey))
					{
						visited.add(rightKey);
						queue.push([r, c + 1]);
					}
				}

				// -- Move Up --
				if (r > 0 && !colBoundaries[r][c])
				{
					const upKey = `${r - 1},${c}`;
					if (!visited.has(upKey))
					{
						visited.add(upKey);
						queue.push([r - 1, c]);
					}
				}

				// -- Move Down --
				if (r < N - 1 && !colBoundaries[r + 1][c])
				{
					const downKey = `${r + 1},${c}`;
					if (!visited.has(downKey))
					{
						visited.add(downKey);
						queue.push([r + 1, c]);
					}
				}
			}

			// If not all cells were visited, there's at least one disconnected component
			return visited.size < (N * N);
		}


		function isGoodGrid(grid)
		{
			return getLargestValue(grid) > N - 2 && !hasIslands(grid);
		}

		async function runGeneration()
		{
			while (true)
			{
				// Reset the iteration count
				iterationCount = 0;
				document.getElementById('iterationCount').textContent = iterationCount;

				// Run a single generation
				runSingleGeneration();

				await new Promise(r => setTimeout(r, 0));

				// Check if the grid is good
				if (isGoodGrid(grid))
				{
					return;
				}
			}
		}

		/*************************************************
		   * 2) Utility for Shuffling Arrays (Fisher-Yates)
		   *************************************************/
		function shuffle(array)
		{
			for (let i = array.length - 1; i > 0; i--)
			{
				const j = Math.floor(Math.random() * (i + 1));
				[array[i], array[j]] = [array[j], array[i]];
			}
		}

		function seedGrid(grid)
		{
			// Choose the row to seed
			const r = Math.floor(Math.random() * N);

			// Generate a random permutation of [1..N]
			const permutation = Array.from({ length: N }, (_, i) => i + 1);
			shuffle(permutation);

			// Seed the row
			for (let c = 0; c < N; c++)
			{
				const v = permutation[c];
				grid[r][c] = v;

				// Choose a segment length between V and N, biased towards V
				const segmentLength = Math.floor(Math.random() * Math.random() * (N - v + 1)) + v;

				// Choose a random starting row
				const minStartRow = Math.max(0, r - segmentLength + 1);
				const maxStartRow = Math.min(r, N - segmentLength);
				const startRow = Math.floor(Math.random() * (maxStartRow - minStartRow + 1)) + minStartRow;

				// Choose a random shuffle of [1..segmentLength]
				const segmentValues = Array.from({ length: segmentLength }, (_, i) => i + 1);
				shuffle(segmentValues);

				// Find the value in the shuffle equal to the current value and swap it with where the
				// row is within this segment
				const valueIndex = segmentValues.indexOf(v);
				const rowIndex = r - startRow;
				[segmentValues[valueIndex], segmentValues[rowIndex]] = [segmentValues[rowIndex], segmentValues[valueIndex]];

				// Fill in the segment
				for (let i = 0; i < segmentLength; i++)
				{
					grid[startRow + i][c] = segmentValues[i];
				}
			}
		}

		/************************************************************
		 *  Increase a single cell's value at random by 1..(N - oldValue)
		 *  and check row/col validity. If invalid, revert.
		 ************************************************************/
		function runSingleGeneration()
		{
			// Reset the grid
			grid = Array.from({ length: N }, () => Array(N).fill(1));
			//seedGrid(grid);

			while (true)
			{
				// Find the largest value currently placed
				let largestValue = 0;
				for (let r = 0; r < N; r++)
				{
					for (let c = 0; c < N; c++)
					{
						largestValue = Math.max(largestValue, grid[r][c]);
					}
				}

				// The largest possible value in the grid is one larger than the largest placed, capped at N
				if (largestValue < N)
				{
					largestValue++;
				}

				let candidates = [];
				let largestViableValue = 0;
				for (let r = 0; r < N; r++)
				{
					for (let c = 0; c < N; c++)
					{
						const curLargestViableValue = getLargestViableValue(grid, r, c, largestValue);
						if (curLargestViableValue > 0)
						{
							if (curLargestViableValue > largestViableValue)
							{
								candidates = [];
								largestViableValue = curLargestViableValue;
							}
							else if (curLargestViableValue < largestViableValue)
							{
								continue;
							}

							candidates.push([r, c, curLargestViableValue]);
						}
					}
				}

				// If no candidates, we're done
				if (candidates.length === 0)
				{
					break;
				}

				// Randomly pick one cell
				const [r, c, newValue] = candidates[Math.floor(Math.random() * candidates.length)];
				grid[r][c] = newValue;
				success = true;

				iterationCount++;
				document.getElementById('iterationCount').textContent = iterationCount;
			}

			// Re-render after the attempt
			renderGrid();
		}

		/************************************************************
		 *  Set up the page on load
		 ************************************************************/
		window.onload = function ()
		{
			// Initial render
			renderGrid();

			// Button click -> run one iteration
			document.getElementById('iterateBtn').addEventListener('click', runGeneration);
		};
	</script>

</body>

</html>